name: CI/CD Pipeline API (Single Server)

on:
  push:
    branches:
      - dev
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  ###################
  #  Build Job      #
  ###################
  build:
    # ... (Le job 'build' reste identique à la version précédente) ...
    # Il construit et pousse l'image vers GHCR avec les tags 'dev', 'latest', et SHA court.
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.meta.outputs.version }} # Exporte le tag SHA court
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=,suffix=,format=short
            type=raw,value=latest,enable=${{ github.ref == format('refs/heads/{0}', 'main') }}
            type=raw,value=dev,enable=${{ github.ref == 'refs/heads/dev' }}
      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64 # Adaptez si nécessaire
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  #########################
  #  Deploy Job (Unique)  #
  #########################
  # Ce job unique gère les deux déploiements en adaptant les commandes
  deploy:
    name: Deploy to Server (${{ github.ref_name }}) # Nom dynamique
    needs: build
    runs-on: ubuntu-latest
    # Condition pour ne s'exécuter que sur push vers dev ou main
    if: github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/main'

    # Définition de l'environnement pour la prod (approbation manuelle optionnelle)
    environment:
      name: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }} # Nom d'environnement dynamique
      url: ${{ github.ref == 'refs/heads/main' && 'https://votre-domaine-prod.com' || 'http://<ip_serveur>:<port_dev>' }} # URL dynamique

    steps:
      - name: Configure SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          # Utilise UN SEUL secret pour la clé privée
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add Server Host Key to known_hosts
        # Utilise UN SEUL secret pour l'hôte
        run: ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Set Environment Variables for Deployment
        id: set_env
        run: |
          if [ "${{ github.ref }}" = "refs/heads/dev" ]; then
            echo "env_suffix=dev" >> $GITHUB_OUTPUT
            echo "image_tag=dev" >> $GITHUB_OUTPUT
            echo "env_file=.env.dev" >> $GITHUB_OUTPUT
            echo "project_name=dev" >> $GITHUB_OUTPUT
          else # refs/heads/main
            echo "env_suffix=prod" >> $GITHUB_OUTPUT
            echo "image_tag=${{ needs.build.outputs.image_tag }}" >> $GITHUB_OUTPUT # Utilise le SHA pour la prod
            echo "env_file=.env.prod" >> $GITHUB_OUTPUT
            echo "project_name=prod" >> $GITHUB_OUTPUT
          fi

      - name: Deploy Application
        env:
          # ... (vos variables env restent les mêmes) ...
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
          PROJECT_PATH: "~/project"
          IMAGE_TAG: ${{ steps.set_env.outputs.image_tag }}
          ENV_SUFFIX: ${{ steps.set_env.outputs.env_suffix }}
          ENV_FILE: ${{ steps.set_env.outputs.env_file }}
          PROJECT_NAME: ${{ steps.set_env.outputs.project_name }}
        run: |
          echo "Deploying tag '${{ env.IMAGE_TAG }}' for environment '${{ env.ENV_SUFFIX }}'..."
          # Ajout de bash -c '...' pour encapsuler toutes les commandes
          ssh -o StrictHostKeyChecking=accept-new ${SSH_USER}@${SSH_HOST} "bash -c '
            set -e # Important de garder set -e à l'intérieur de bash -c

            echo \"Navigating to project directory...\" # Guillemets internes échappés
            cd ${{ env.PROJECT_PATH }}

            # Met à jour le tag dans le BON fichier .env (.env.dev ou .env.prod)
            echo \"Updating ${{ env.ENV_FILE }} with IMAGE_TAG=${{ env.IMAGE_TAG }}\"
            if grep -q \"^IMAGE_TAG=\" ${{ env.ENV_FILE }}; then # Guillemets autour de la regex
              sed -i \"s|^IMAGE_TAG=.*$|IMAGE_TAG=${{ env.IMAGE_TAG }}|\" ${{ env.ENV_FILE }} # Guillemets autour de l'expression sed
            else
              echo \"IMAGE_TAG=${{ env.IMAGE_TAG }}\" >> ${{ env.ENV_FILE }}
            fi

            # Pull l'image (tag 'dev' ou SHA spécifique)
            echo \"Pulling new API image (tag: ${{ env.IMAGE_TAG }})...\"
            docker compose -p ${{ env.PROJECT_NAME }} --env-file ${{ env.ENV_FILE }} pull api

            # Redémarre les services pour cet environnement spécifique
            echo \"Starting services for project ${{ env.PROJECT_NAME }}...\"
            docker compose -p ${{ env.PROJECT_NAME }} --env-file ${{ env.ENV_FILE }} up -d --remove-orphans

            # Nettoyage global des images
            echo \"Pruning old docker images...\"
            docker image prune -af

            echo \"Deployment for environment ${{ env.ENV_SUFFIX }} finished successfully.\"
          '" # Fin de la chaîne pour bash -c et pour ssh
